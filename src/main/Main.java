package main;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.Set;

public class Main {

	static HashMap<Integer, HashMap<Integer, Integer>> rawData;
	final static int MAX_DIFFERENCE = 16;
	final static String[] CF_NAMES = { "MeanSquareDifferences", "PearsonCorrelationCoefficient" };
	final static String[] PREDICTION_NAMES = { "MeanValuePrediction", "DistanceBasedPrediction", "ResnicksFormula" };
	final static String[] NEIGHBOURSELECTION_NAMES = { "NoNeighbourSelection", "FixedSize", "SimilarityBounded" };

	public static void main(String[] args) throws IOException {
		rawData = new HashMap<>();
		retriveData("100k.dat");
		initializeAndGenerateStatistics(false);// initialization
		if (args.length >= 3) {
			calcRuntime(0, Integer.valueOf(args[0]), Integer.valueOf(args[1]), Double.valueOf(args[2]), 1);
		}
		// switch (args[0]) {// judge which cases to run, used for testing, no use for grading
		// case "0":
		// calcRuntime(0, 0, 0, 0, 1);
		// calcRuntime(0, 1, 0, 0, 1);
		// calcRuntime(0, 2, 0, 0, 1);
		// break;
		// case "1":
		// for (int size = 50; size <= 700; size += 50) {
		// calcRuntime(0, 1, 1, size, 1);
		// calcRuntime(0, 2, 1, size, 1);
		// }
		// break;
		// case "2":
		// for (int size = 750; size <= 900; size += 50) {
		// calcRuntime(0, 1, 1, size, 1);
		// calcRuntime(0, 2, 1, size, 1);
		// }
		// for (float bound = 0.1f; bound < 1; bound += 0.1f) {
		// calcRuntime(0, 1, 2, bound, 1);
		// calcRuntime(0, 2, 2, bound, 1);
		// }
		// calcRuntime(0, 1, 2, 0.9, 1);
		// calcRuntime(0, 2, 2, 0.9, 1);
		// break;
		// default:
		// break;
		// }
		// generateRawCSV();//generate a table contain all user-item relations
	}

	static HashMap<Integer, ArrayList<Integer>> itemMap;
	private static int totalRatingCount = 0;
	private static HashMap<Integer, Double> meanRatings = new HashMap<>();

	/**
	 * Calculate the average time cost of a technique
	 * 
	 * @param cf
	 *            Index of CF approach(This parameter is deprecated)
	 *            </br>
	 *            &emsp;0 is Mean Square Differences </br>
	 *            &emsp;1 is Pearson¡¯s Correlation Coefficient</br>
	 * @param prediction
	 *            Index of technique to be evaluated
	 *            </br>
	 *            &emsp;0 is mean value prediction </br>
	 *            &emsp;1 is distance-based prediction</br>
	 *            &emsp;2 is Resnick¡¯s Formula
	 * @param neiSe
	 *            Index of neighbourhood selection strategy
	 *            </br>
	 *            &emsp;0 is no selection </br>
	 *            &emsp;1 is Fixed Size Neighbourhoods</br>
	 *            &emsp;2 is Similarity Bounded Neighbourhoods
	 * @param neiArg
	 *            Argument for neighbourhood selection
	 * @param times
	 *            Times to loop
	 * @throws IOException
	 */
	public static void calcRuntime(int cf, int prediction, int neiSe, double neiArg, int times) throws IOException {
		long startTime, endTime, averageTime = 0;
		for (int i = 0; i < times; i++) {
			startTime = Calendar.getInstance().getTimeInMillis();
			System.out.println("RMSE: " + rootMeanSquaredError(cf, prediction, neiSe, neiArg));
			endTime = Calendar.getInstance().getTimeInMillis();
			averageTime += endTime - startTime;
		}
		averageTime = averageTime / times;
		System.out.println("Time Cost: " + averageTime + "ms");
	}

	/**
	 * Neighbour selection strategies
	 * 
	 * @param neighbours
	 *            similarity matrix generated by CF methods
	 * @param optimazationIndex
	 *            (see javadoc of method calcRuntime)
	 * @param arg
	 * @return similarity matrix processed by neighbour selection
	 */
	public static HashMap<Integer, Double> neighbourhoodOptimal(HashMap<Integer, Double> neighbours, int optimazationIndex, double arg) {
		switch (optimazationIndex) {
		case 0:// no selection
			return neighbours;
		case 1:// top N
			double threshold = arg;
			double tempMean = -1;
			if (neighbours.containsKey(-1)) {// left a place for index -1 (which stores average rating after left one out)
				tempMean = neighbours.remove(-1);
				threshold++;
			}
			ArrayList<Entry<Integer, Double>> topList = new ArrayList<>();
			topList.addAll(neighbours.entrySet());
			topList.sort(new Comparator<Entry<Integer, Double>>() {
				@Override
				public int compare(Entry<Integer, Double> o1, Entry<Integer, Double> o2) {
					return ((Double) Math.abs(o1.getValue())).compareTo(Math.abs(o2.getValue()));
				}
			});
			for (int i = 0; i < topList.size() - threshold; i++) {
				neighbours.remove(topList.get(i).getKey());
			}
			if (tempMean != -1)
				neighbours.put(-1, tempMean);
			return neighbours;
		case 2:// similarity bounded
			HashMap<Integer, Double> teMap = new HashMap<>();
			teMap.putAll(neighbours);
			Iterator<Entry<Integer, Double>> neighbourIter = neighbours.entrySet().iterator();
			while (neighbourIter.hasNext()) {
				Entry<Integer, Double> neighbour = neighbourIter.next();
				int neiName = neighbour.getKey();
				if (neiName == -1) {
					continue;
				}
				double neiSim = neighbour.getValue();
				if (Math.abs(neiSim) < arg) {
					teMap.remove(neiName);
				}
			}
			return teMap;
		default:
			break;
		}
		return null;

	}

	/**
	 * Generate Pearson's Correlation Coefficient matrices
	 * 
	 * @param userid
	 * @param itemid
	 * @return
	 */
	public static HashMap<Integer, Double> generatePearsonCorrelationSimMatrix(int userid, int itemid) {
		HashMap<Integer, Integer> iContent = rawData.get(userid);
		HashMap<Integer, Double> rowMap = new HashMap<>();
		double l1oMeanRating = 0;
		if (meanRatings.isEmpty())
			calculateMeanRatings();// calculate mean ratings if they're not calculated
		if (itemid == 0) {
			l1oMeanRating = meanRatings.get(userid);
		} else if (iContent.size() > 1) {// calculate L1O mean rating if the user has more than 1 rating
			l1oMeanRating = (iContent.size() * meanRatings.get(userid) - iContent.get(itemid)) / (iContent.size() - 1);// calculating method: (mean rating * rating number - left rating)/(rating number - 1)
		}
		Iterator<Entry<Integer, HashMap<Integer, Integer>>> userIterator = rawData.entrySet().iterator();
		while (userIterator.hasNext()) {
			Entry<Integer, HashMap<Integer, Integer>> userEntry = userIterator.next();
			int jName = userEntry.getKey();
			HashMap<Integer, Integer> jContent = userEntry.getValue();
			if (jName == userid)
				continue;
			HashSet<Integer> intSec = findIntersection(userid, jName, iContent.keySet(), jContent.keySet());
			double iDiff = 0, jDiff = 0, up = 0, downLeft = 0, downRight = 0, sim = 0;
			boolean anythingRemoved = intSec.remove(itemid);// remove the left item in overlap set if it exists
			if (intSec.size() > 0) {
				Iterator<Integer> intSecIter = intSec.iterator();
				while (intSecIter.hasNext()) {// loop all items rated by both users except for the left one
					int commonItemId = intSecIter.next();
					iDiff = iContent.get(commonItemId) - l1oMeanRating;
					jDiff = jContent.get(commonItemId) - meanRatings.get(jName);
					up += iDiff * jDiff;
					downLeft += Math.pow(iDiff, 2);
					downRight += Math.pow(jDiff, 2);
				}
				if (downLeft == 0 || downRight == 0 || up == 0) {
					sim = 0;
				} else {
					sim = up / (Math.sqrt(downLeft) * Math.sqrt(downRight));
					rowMap.put(jName, sim);
				}
			}
			if (anythingRemoved)// restore the overlap set
				intSec.add(itemid);
		}
		rowMap.put(-1, l1oMeanRating);// store L1O mean rating
		return rowMap;
	}

	/**
	 * Generate mean ratings for all users
	 */
	public static void calculateMeanRatings() {
		Iterator<Entry<Integer, HashMap<Integer, Integer>>> totalIterator = rawData.entrySet().iterator();
		while (totalIterator.hasNext()) {
			Entry<Integer, HashMap<Integer, Integer>> usrEntry = totalIterator.next();
			Iterator<Entry<Integer, Integer>> itemIterator = usrEntry.getValue().entrySet().iterator();
			double mean = 0;
			while (itemIterator.hasNext()) {
				mean += itemIterator.next().getValue();
			}
			mean /= usrEntry.getValue().size();
			meanRatings.put(usrEntry.getKey(), mean);
		}
	}

	/**
	 * Generate distance based neighborhood for a given user
	 * 
	 * @param userid
	 *            user
	 * @param itemid
	 *            left out item
	 * @return A table stored distance matrix
	 */
	public static HashMap<Integer, Double> generateDistanceNeighbourMatrix(int userid, int itemid) {
		HashMap<Integer, Integer> iContent = rawData.get(userid);
		Iterator<Entry<Integer, HashMap<Integer, Integer>>> userIterator = rawData.entrySet().iterator();
		HashMap<Integer, Double> rowMap = new HashMap<>();
		while (userIterator.hasNext()) {// compare with all other users
			double sim = 0d;
			Entry<Integer, HashMap<Integer, Integer>> jEntry = userIterator.next();
			int jName = jEntry.getKey();
			if (jName == userid)
				continue;
			HashMap<Integer, Integer> jContent = jEntry.getValue();
			HashSet<Integer> intSec = findIntersection(userid, jName, iContent.keySet(), jContent.keySet());
			boolean anythingRemoved = intSec.remove(itemid);// remove the left item if it exists
			if (intSec.size() > 0) {
				Iterator<Integer> intersectionIterator = intSec.iterator();
				while (intersectionIterator.hasNext()) {
					int commonItemId = intersectionIterator.next();
					sim += Math.pow(iContent.get(commonItemId) - jContent.get(commonItemId), 2);
				}
				sim /= intSec.size();
			}
			if (anythingRemoved)// return the left item if it's removed
				intSec.add(itemid);
			rowMap.put(jName, sim);// store in distance matrix
		}
		return rowMap;
	}

	private static HashMap<Integer, HashMap<Integer, HashSet<Integer>>> overlap = new HashMap<>();

	/**
	 * Find overlap for two users
	 * 
	 * @param iName
	 *            user1
	 * @param jName
	 *            user2
	 * @param iItems
	 *            Rated item set of user1
	 * @param jItems
	 *            Rated item set of user2
	 * @return A set of overlap
	 */
	public static HashSet<Integer> findIntersection(int iName, int jName, Set<Integer> iItems, Set<Integer> jItems) {
		if (!overlap.containsKey(iName) || !overlap.get(iName).containsKey(jName)) {
			HashSet<Integer> intersection = new HashSet<>();
			if (iItems.size() > jItems.size()) {
				intersection.addAll(iItems);
				intersection.retainAll(jItems);
			} else {
				intersection.addAll(jItems);
				intersection.retainAll(iItems);
			}
			if (overlap.containsKey(iName)) {
				overlap.get(iName).put(jName, intersection);
			} else {
				HashMap<Integer, HashSet<Integer>> column = new HashMap<>();
				column.put(jName, intersection);
				overlap.put(iName, column);
			}
			if (overlap.containsKey(jName)) {
				overlap.get(jName).put(iName, intersection);
			} else {
				HashMap<Integer, HashSet<Integer>> column = new HashMap<>();
				column.put(iName, intersection);
				overlap.put(jName, column);
			}
		}
		return overlap.get(iName).get(jName);
	}

	/**
	 * Calculate the RMSE of all predicted data
	 * 
	 * @param cf
	 * @param predictionTechnique
	 * @param neiSe
	 * @param neiArg
	 * @return RMSE
	 * @throws IOException
	 */
	public static double rootMeanSquaredError(int cf, int predictionTechnique, int neiSe, double neiArg) throws IOException {
		long startTime = Calendar.getInstance().getTimeInMillis();
		int evaluationCount = 0;
		String fileName = "";
		if (predictionTechnique == 0) {
			fileName += PREDICTION_NAMES[predictionTechnique];
		} else {
			fileName += CF_NAMES[predictionTechnique - 1] + "_" + PREDICTION_NAMES[predictionTechnique] + "_" + NEIGHBOURSELECTION_NAMES[neiSe];
		}
		if (neiSe != 0) {
			if (neiArg >= 1)
				fileName += "_" + (int) neiArg;
			else
				fileName += "_" + neiArg;
		}
		System.out.println(fileName);
		File csv = new File(fileName + ".csv");
		csv.createNewFile();
		BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(csv)));
		double rmse = 0;
		int currentUser = -1;
		Iterator<Entry<Integer, HashMap<Integer, Integer>>> totalIterator = rawData.entrySet().iterator();
		double count = 0;
		System.out.print("[");
		while (totalIterator.hasNext()) {
			Entry<Integer, HashMap<Integer, Integer>> userEntry = totalIterator.next();
			currentUser = userEntry.getKey();
			HashMap<Integer, Integer> row = userEntry.getValue();
			Iterator<Entry<Integer, Integer>> rowIterator = row.entrySet().iterator();
			while (rowIterator.hasNext()) {
				double progress = count * 100d / totalRatingCount;
				if (progress % 1 == 0 && progress > 0) {
					System.out.print("=");
				}
				if (progress % 5 == 0 && progress > 0 && progress < 100 && progress % 10 != 0) {
					System.out.print(" ");
				}
				if (progress % 10 == 0 && progress > 0 && progress < 100) {
					System.out.print(String.format("%.0f%%", count * 100d / totalRatingCount));
				}
				Entry<Integer, Integer> itemEntry = rowIterator.next();
				double prediction = 0;
				HashMap<Integer, Double> neighbours;
				switch (predictionTechnique) {
				case 0:
					prediction = mean_item_rating(currentUser, itemEntry.getKey());
					break;
				case 1:
					neighbours = neighbourhoodOptimal(generateDistanceNeighbourMatrix(currentUser, itemEntry.getKey()), neiSe, neiArg);
					Iterator<Entry<Integer, Double>> neighbourIter1 = neighbours.entrySet().iterator();
					double up = 0, down = 0;
					while (neighbourIter1.hasNext()) {
						Entry<Integer, Double> user = neighbourIter1.next();
						double wj = 1 - user.getValue() / MAX_DIFFERENCE;
						int j = user.getKey();
						if (!rawData.get(j).containsKey(itemEntry.getKey())) {
							continue;
						}
						up += wj * rawData.get(j).get(itemEntry.getKey());
						down += wj;
					}
					if (down == 0)
						prediction = 0;
					else
						prediction = up / down;
					break;
				case 2:
					neighbours = neighbourhoodOptimal(generatePearsonCorrelationSimMatrix(currentUser, itemEntry.getKey()), neiSe, neiArg);
					Iterator<Entry<Integer, Double>> neighbourIter2 = neighbours.entrySet().iterator();
					if (neighbours.containsKey(-1))
						prediction = neighbours.get(-1);// it should be mean ratings of user after L1O
					double pup = 0, pdown = 0;
					while (neighbourIter2.hasNext()) {// loop all neighbours
						Entry<Integer, Double> user = neighbourIter2.next();
						int j = user.getKey();
						if (user.getKey() == -1 || !rawData.get(j).containsKey(itemEntry.getKey()))
							continue;
						pup += (rawData.get(j).get(itemEntry.getKey()) - meanRatings.get(j)) * user.getValue();
						pdown += Math.abs(user.getValue());
					}
					double right = 0;
					if (pdown != 0) {
						right = pup / pdown;
					}
					if (right != 0) {
						prediction += right;
					} else {// if right side of formula equals zero, consider this prediction useless
						prediction = 0;
					}
					break;
				default:
					break;
				}
				double error;
				if (prediction == 0)
					error = 0;// no prediction for this tuple
				else {
					evaluationCount++;// valid prediction
					error = Math.abs(prediction - itemEntry.getValue());
					rmse += Math.pow(error, 2);
				}
				if (prediction != 0)
					writer.write(currentUser + ", " + itemEntry.getKey() + ", " + itemEntry.getValue() + ", " + prediction + "\n");
				count++;
			}
		}
		System.out.println("=]");
		rmse = Math.sqrt(rmse / (1.0d * evaluationCount));
		writer.write("RMSE:" + "," + rmse + "," + "Coverage: ," + evaluationCount * 1.0d / totalRatingCount + ", Time Cost: ," + (Calendar.getInstance().getTimeInMillis() - startTime));
		writer.flush();
		writer.close();
		System.out.println("Coverage: " + evaluationCount * 1.0d / totalRatingCount);
		return rmse;
	}

	/**
	 * Predict rating by calculating mean value
	 * 
	 * @param user_id
	 *            User to be predicted
	 * @param item_id
	 *            Item to be predicted
	 * @return
	 */
	public static float mean_item_rating(int user_id, int item_id) {
		float mean = 0;
		Iterator<Integer> columnIterator = itemMap.get(item_id).iterator();
		while (columnIterator.hasNext()) {
			mean += columnIterator.next();
		}
		if (!rawData.containsKey(user_id)) {
			System.err.println("No such user");
			return 0;
		}
		if (rawData.get(user_id).containsKey(item_id)) {
			mean -= rawData.get(user_id).get(item_id);
		}
		if (mean != 0) {
			return mean / (itemMap.get(item_id).size() - 1);
		} else {
			return 0;
		}
	}

	/**
	 * Count the covered rating number
	 * 
	 * @param techniqueIndex
	 * @return Number of covered
	 */
	public static int coverageCount(int techniqueIndex) {
		int coverage = 0;
		int currentUser;
		Set<Integer> userSet = rawData.keySet();
		Set<Integer> itemSet = itemMap.keySet();
		Iterator<Integer> userSetIterator = userSet.iterator();
		while (userSetIterator.hasNext()) {
			currentUser = userSetIterator.next();
			Iterator<Integer> itemSetIterator = itemSet.iterator();
			while (itemSetIterator.hasNext()) {
				switch (techniqueIndex) {
				case 0:
					if (mean_item_rating(currentUser, itemSetIterator.next()) >= 1)
						coverage++;
					break;
				default:
					break;
				}
			}
		}
		return coverage;
	}

	/**
	 * Calculate the coverage of a technique
	 * 
	 * @param techniqueIndex
	 *            Index of technique
	 * @return Coverage
	 */
	public static double coverage(int techniqueIndex) {
		Set<Integer> userSet = rawData.keySet();
		Set<Integer> itemSet = itemMap.keySet();
		return coverageCount(techniqueIndex) / (1.0d * (userSet.size() * itemSet.size()));
	}

	/**
	 * Process the pre-processed data further and generate statistics data
	 * 
	 * @param generateStat
	 *            If generating stat.csv file
	 * 
	 * @throws IOException
	 */
	public static void initializeAndGenerateStatistics(boolean generateStat) throws IOException {
		File statFile;
		BufferedWriter fileWriter = null;
		if (generateStat) {
			statFile = new File("stat.csv");
			statFile.createNewFile();
			fileWriter = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(statFile)));
		}
		itemMap = new HashMap<>();
		int ratingCount[] = { 0, 0, 0, 0, 0 };
		Iterator<Entry<Integer, HashMap<Integer, Integer>>> totalIterator = rawData.entrySet().iterator();
		if (generateStat)
			fileWriter.write("User,Mean,Median,Standard deviation,Max,Min\n");
		while (totalIterator.hasNext()) {
			Entry<Integer, HashMap<Integer, Integer>> userEntry = totalIterator.next();
			HashMap<Integer, Integer> row = userEntry.getValue();
			Iterator<Entry<Integer, Integer>> rowIterator = row.entrySet().iterator();
			float rowSum = 0, rowSqrSum = 0;
			float mean, median, max = 0, min = Integer.MAX_VALUE;
			double stddeviation;
			while (rowIterator.hasNext()) {
				Entry<Integer, Integer> cell = rowIterator.next();
				int rate = cell.getValue();
				ratingCount[rate - 1]++;
				if (!itemMap.containsKey(cell.getKey())) {
					ArrayList<Integer> rateOfItem = new ArrayList<>();
					rateOfItem.add(cell.getValue());
					itemMap.put(cell.getKey(), rateOfItem);
				} else
					itemMap.get(cell.getKey()).add(cell.getValue());

				rowSum += rate;
				rowSqrSum += rate * rate;
				max = Math.max(rate, max);
				min = Math.min(min, rate);
			}
			ArrayList<Integer> rateList = new ArrayList<>();
			rateList.addAll(row.values());
			rateList.trimToSize();
			mean = rowSum / row.size();
			median = calcMedian(rateList);
			stddeviation = Math.sqrt(rowSqrSum / rateList.size() - mean * mean);
			totalRatingCount += row.size();

			if (generateStat)
				fileWriter.write("User" + userEntry.getKey() + "," + mean + "," + median + "," + stddeviation + "," + max + "," + min + "\n");
		}

		if (generateStat)
			fileWriter.write("Item,Mean,Median,Standard deviation,Max,Min\n");
		Iterator<Entry<Integer, ArrayList<Integer>>> itemIterator = itemMap.entrySet().iterator();
		while (itemIterator.hasNext()) {
			Entry<Integer, ArrayList<Integer>> itemEntry = itemIterator.next();
			float columnSum = 0, columnSqrSum = 0;
			float mean, median, max = 0, min = Integer.MAX_VALUE;
			double stddeviation;
			Iterator<Integer> columnIterator = itemEntry.getValue().iterator();
			while (columnIterator.hasNext()) {
				int tempRate = (int) columnIterator.next();
				columnSum += tempRate;
				columnSqrSum += tempRate * tempRate;
				max = Math.max(max, tempRate);
				min = Math.min(min, tempRate);
			}
			mean = columnSum / itemEntry.getValue().size();
			median = calcMedian(itemEntry.getValue());
			stddeviation = Math.sqrt(columnSqrSum / itemEntry.getValue().size() - mean * mean);
			if (generateStat)
				fileWriter.write("Item" + itemEntry.getKey() + "," + mean + "," + median + "," + stddeviation + "," + max + "," + min + "\n");
		}
		if (generateStat) {
			fileWriter.write("Total number of users: " + rawData.keySet().size() + "\n");
			fileWriter.write("Total number of items: " + itemMap.size() + "\n");
			fileWriter.write("Total number of ratings: " + totalRatingCount + "\n");
			fileWriter.write("Ratings density: " + (double) totalRatingCount / (rawData.keySet().size() * itemMap.size()) + "\n");
			for (int i = 0; i < 5; i++) {
				fileWriter.write("Number of " + (i + 1) + "-stars: " + ratingCount[i] + "\n");
			}
			fileWriter.close();
		}
	}

	/**
	 * Find the median of a set of numbers
	 * 
	 * @param list
	 *            An array list of integer
	 * @return median
	 */
	private static float calcMedian(ArrayList<Integer> list) {
		Collections.sort(list);
		if (list.size() % 2 == 0)
			return ((float) list.get(list.size() / 2) + (float) list.get(list.size() / 2 - 1)) / 2;
		else
			return list.get(list.size() / 2);

	}

	/**
	 * Read and pre-process 100k.dat file
	 * 
	 * @param path
	 *            path of file
	 */
	public static void retriveData(String path) {
		File mlSet = new File(path);
		if (mlSet.canRead()) {
			try {
				BufferedReader bReader = new BufferedReader(new InputStreamReader(new FileInputStream(mlSet)));
				String line = bReader.readLine();
				String temp[];
				while (line != null) {
					temp = line.split(",");
					int values[] = new int[3];
					for (int i = 0; i < 3; i++) {
						values[i] = Integer.parseInt(temp[i]);
					}
					if (rawData.containsKey(values[0])) {
						rawData.get(values[0]).put(values[1], values[2]);
					} else {
						HashMap<Integer, Integer> item = new HashMap<>();
						item.put(values[1], values[2]);
						rawData.put(values[0], item);
					}
					line = bReader.readLine();
				}

				bReader.close();
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			} catch (IOException e) {
				e.printStackTrace();
			}

		}
	}

	/**
	 * Optional method for generating raw data as a table
	 * 
	 * @throws IOException
	 */
	@SuppressWarnings("unused")
	private static void generateRawCSV() throws IOException {
		File completeTable = new File("table.csv");
		completeTable.createNewFile();
		BufferedWriter fileWriter = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(completeTable)));
		fileWriter.write("-,");
		Iterator<Entry<Integer, HashMap<Integer, Integer>>> totalIterator = rawData.entrySet().iterator();
		Iterator<Entry<Integer, ArrayList<Integer>>> itemIterator = itemMap.entrySet().iterator();
		while (itemIterator.hasNext()) {
			fileWriter.write(itemIterator.next().getKey().toString());
			if (itemIterator.hasNext()) {
				fileWriter.write(",");
			} else {
				fileWriter.write("\n");
			}
		}
		while (totalIterator.hasNext()) {
			Entry<Integer, HashMap<Integer, Integer>> userEntry = totalIterator.next();
			fileWriter.write(userEntry.getKey() + ",");
			itemIterator = itemMap.entrySet().iterator();
			while (itemIterator.hasNext()) {
				Entry<Integer, ArrayList<Integer>> cell = itemIterator.next();
				if (userEntry.getValue().containsKey(cell.getKey())) {
					fileWriter.write(userEntry.getValue().get(cell.getKey()).toString());
				} else {
					fileWriter.write(String.valueOf(0));
				}
				if (itemIterator.hasNext()) {
					fileWriter.write(",");
				}
			}
			fileWriter.write("\n");
		}
		fileWriter.close();
	}
}
